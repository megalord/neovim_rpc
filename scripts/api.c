#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cmp.c"

bool file_reader (cmp_ctx_t *ctx, void *data, size_t limit) {
  return fread(data, sizeof(uint8_t), limit, ctx->buf) == (limit * sizeof(uint8_t));
}

typedef struct {
  char name[20];
  char type[20];
  bool is_ptr;
  bool is_arr;
  char cmp_fn[80];
} param_t;

typedef struct {
  char name[40];
  bool deprecated;
  param_t ret;
  uint32_t num_params;
  param_t *params;
} func_t;

size_t null_writer (cmp_ctx_t *ctx, const void *data, size_t count) {
  fprintf(stderr, "do not write to the output\n");
  exit(1);
}

void error_and_exit (const char str[]) {
  fprintf(stderr, "%s\n", str);
  exit(1);
}

void read_version (cmp_ctx_t *cmp) {
  uint32_t map_size;
  cmp_read_map(cmp, &map_size);

  uint8_t major, minor, patch, val;
  for (int i = 0; i < map_size; i++) {
    uint32_t key_size = 20;
    char key[key_size];
    if(!cmp_read_str(cmp, key, &key_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }

    cmp_object_t cmp_obj;
    if (!cmp_read_pfix(cmp, &val)) {
      if (cmp->error != INVALID_TYPE_ERROR) {
        error_and_exit(cmp_strerror(cmp));
      }
    }

    if (strcmp(key, "major") == 0) {
      major = val;
    } else if (strcmp(key, "minor") == 0) {
      minor = val;
    } else if (strcmp(key, "patch") == 0) {
      patch = val;
    }
  }

  printf("// This file is automatically generated.  It was built against Neovim Version %i.%i.%i\n\n", major, minor, patch);
}

void print_param (param_t *param) {
  printf("%s ", param->type);
  if (param->is_arr) {
    printf("*");
  }
  if (param->is_ptr) {
    printf("*");
  }
  printf("%s", param->name);
  if (param->is_arr) {
    printf(", uint32_t *size");
  }
}

void translate_param (param_t *param) {
  // See https://github.com/neovim/neovim/blob/master/src/nvim/api/private/defs.h
  // TODO: fix array writes
  char type[20];
  strcpy(type, param->type);
  if (strcmp(type, "String") == 0) {
    strcpy(param->type, "char");
    param->is_ptr = true;
    snprintf(param->cmp_fn, 80, "cmp_write_str(&cmp, %s, strlen(%s))", param->name, param->name);
  } else if (strcmp(type, "Integer") == 0) {
    strcpy(param->type, "int64_t");
    snprintf(param->cmp_fn, 80, "cmp_write_integer(&cmp, %s)", param->name);
  } else if (strcmp(type, "Boolean") == 0) {
    strcpy(param->type, "bool");
    snprintf(param->cmp_fn, 80, "cmp_write_bool(&cmp, %s)", param->name);
  } else if (strcmp(type, "Array") == 0) {
    strcpy(param->type, "void");
    param->is_arr = true;
    param->is_ptr = true;
    snprintf(param->cmp_fn, 80, "cmp_write_array(&cmp, *size)");
  } else if (strncmp(type, "ArrayOf", 7) == 0) {
    // "return_type": "ArrayOf(Integer, 2)",
    char new_type[20];
    char size[20];
    strncpy(new_type, type + 8, strlen(type) - 9);
    char *c = strchr(new_type, ',');
    if (c == NULL) {
      strcpy(param->type, new_type);
      snprintf(size, sizeof(size), "sizeof(%s)", param->name);
    } else {
      strncpy(param->type, new_type, c - new_type);
      param->type[c - new_type] = '\0';
      strcpy(size, c + 2);
    }
    param->is_arr = true;
    param->is_ptr = true;
    snprintf(param->cmp_fn, 80, "cmp_write_array(&cmp, %s)", size);

    param_t p2;
    strcpy(p2.name, "tmp");
    strcpy(p2.type, param->type);
    translate_param(&p2);
    strcpy(param->type, p2.type);
  } else if (strcmp(type, "Buffer") == 0 || strcmp(type, "Tabpage") == 0 || strcmp(type, "Window") == 0) {
    snprintf(param->cmp_fn, 80, "cmp_write_ext(&cmp, NVIM_EXT_%s, sizeof(%s), &%s)", type, param->name, param->name);
  } else {
    if (strcmp(type, "Object") == 0 || strcmp(type, "Dictionary") == 0) {
      strcpy(param->type, "void");
      param->is_ptr = true;
    }
    snprintf(param->cmp_fn, 80, "cmp_write_str(&cmp, %s, sizeof(%s))", param->name, param->name);
  }
}

void read_parameters (cmp_ctx_t *cmp, param_t **params, uint32_t *num_params) {
  cmp_object_t cmp_obj;
  uint32_t not_used;
  uint32_t name_size = 20;
  char name[name_size];
  uint32_t type_size = 20;
  char type[type_size];

  if (!cmp_read_array(cmp, num_params)) {
    error_and_exit(cmp_strerror(cmp));
  }
  *params = malloc(*num_params * sizeof(param_t));
  for (int i = 0; i < *num_params; i++) {
    if (!cmp_read_array(cmp, &not_used)) {
      error_and_exit(cmp_strerror(cmp));
    }
    if (!cmp_read_str(cmp, type, &name_size)) {
      error_and_exit(cmp_strerror(cmp));
    }
    name_size = 20;
    if (!cmp_read_str(cmp, name, &type_size)) {
      error_and_exit(cmp_strerror(cmp));
    }
    type_size = 20;
    param_t p = { .is_arr = false, .is_ptr = false };
    strcpy(p.name, name);
    strcpy(p.type, type);
    translate_param(&p);
    (*params)[i] = p;
  }
}

/*
char[] translate_type (char type[]) {
  if (strcmp(type, "Window") == 0) {
    return { .cmp = "cmp_write_ext(cmp, 0, size, data)"  }
  } else if (strcmp(type, "Object") == 0) {
  }
}
*/

void print_result_collector (param_t *p) {
  char star[2];
  char p_inc[40];
  printf("  if (!read_message_headers()) {\n    return false;\n  }\n");
  if (p->is_arr) {
    printf("  if (!cmp_read_array(&cmp, size)) {\n    return false;\n  }\n");
    printf("  *result = malloc(*size * sizeof(%s));\n", p->type);
    printf("  for (int i = 0; i < *size; i++) {\n");
    strcpy(star, "*");
    sprintf(p_inc, " + i * sizeof(%s)", p->type);
  } else {
    strcpy(star, "");
    strcpy(p_inc, "");
  }
  if (strcmp(p->type, "char") == 0) {
    printf("  if (!read_string(%sresult%s)) {\n    return false;\n  }\n", star, p_inc);
  } else if (strcmp(p->type, "int64_t") == 0) {
    printf("  if (!cmp_read_integer(&cmp, %sresult%s)) {\n    return false;\n  }\n", star, p_inc);
  } else if (strcmp(p->type, "Buffer") == 0) {
    printf("  int8_t ext_type;\n  uint32_t ext_size;\n");
    printf("  if (!cmp_read_ext(&cmp, &ext_type, &ext_size, %sresult%s)) {\n    return false;\n  }\n", star, p_inc);
  }
  if (p->is_arr) {
    printf("  }\n");
  }
  printf("  return true;\n");
}

void print_function (func_t *fn_ptr) {
  func_t fn = *fn_ptr;
  printf("bool %s (", fn.name);
  if (fn.num_params > 0) {
    print_param(&fn.params[0]);
    for (int i = 1; i < fn.num_params; i++) {
      printf(", ");
      print_param(&fn.params[i]);
    }
  }
  if (strcmp(fn.ret.type, "void") != 0) {
    if (fn.num_params > 0) {
      printf(", ");
    }
    bool is_ptr = fn.ret.is_ptr;
    fn.ret.is_ptr = true;
    print_param(&fn.ret);
    fn.ret.is_ptr = is_ptr;
    //printf("rpc_message *response");
  }
  printf(") {\n");
  printf("  if (!rpc_send(NVIM_RPC_REQUEST, \"%s\", %i)) {\n    return false;\n  }\n", fn.name, fn.num_params);
  for (int i = 0; i < fn.num_params; i++) {
    printf("  if (!%s) {\n    return false;\n  }\n", fn.params[i].cmp_fn);
  }
  if (strcmp(fn.ret.type, "void") != 0) { // TODO: will void still send response/
    print_result_collector(&fn.ret);
    //printf("  return wait_for_response(response);\n");
  } else {
    printf("  return true;\n");
  }
  printf("}\n\n");
}

void read_function (cmp_ctx_t *cmp, func_t *fn) {
  uint32_t map_size;
  cmp_read_map(cmp, &map_size);

  fn->deprecated = false;
  uint32_t name_size = sizeof(fn->name);
  uint32_t ret_type_size = sizeof(fn->ret.type);

  for (int i = 0; i < map_size; i++) {
    uint32_t key_size = 20;
    char key[key_size];
    if(!cmp_read_str(cmp, key, &key_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }

    if (strcmp(key, "name") == 0) {
      if (!cmp_read_str(cmp, fn->name, &name_size)) {
        error_and_exit(cmp_strerror(cmp));
      }
    } else if (strcmp(key, "return_type") == 0) {
      if (!cmp_read_str(cmp, fn->ret.type, &ret_type_size)) {
        error_and_exit(cmp_strerror(cmp));
      }
      strcpy(fn->ret.name, "result");
      translate_param(&fn->ret);
    } else if (strcmp(key, "parameters") == 0) {
      read_parameters(cmp, &fn->params, &fn->num_params);
    } else {
      if (strcmp(key, "deprecated_since") == 0) {
        fn->deprecated = true;
      }
      cmp_object_t cmp_obj;
      if (!cmp_read_object(cmp, &cmp_obj)) {
        error_and_exit(cmp_strerror(cmp));
      }
    }
  }
}

//ArrayOf(Integer, 2) nvim_win_get_position (Window window) {
//nvim_win_get_position (Window window, uint8_t *width, uint8_t *height)

void read_functions (cmp_ctx_t *cmp, func_t **fns, uint32_t *num_funcs) {
  cmp_read_array(cmp, num_funcs);
  *fns = malloc(*num_funcs * sizeof(func_t));

  for (int i = 0; i < *num_funcs; i++) {
    read_function(cmp, &((*fns)[i]));
  }
}

void read_error_types (cmp_ctx_t *cmp) {
  uint32_t map_size;
  if (!cmp_read_map(cmp, &map_size)) {
    error_and_exit(cmp_strerror(cmp));
  }

  uint32_t key_size = 12;
  char key[key_size];
  uint32_t id_size = 10;
  char id_key[id_size];
  uint8_t id;
  for (int i = 0; i < map_size; i++) {
    if(!cmp_read_str(cmp, key, &key_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }
    key_size = 12;

    uint32_t sub_map_size;
    if (!cmp_read_map(cmp, &sub_map_size)) {
      error_and_exit(cmp_strerror(cmp));
    }

    if(!cmp_read_str(cmp, id_key, &id_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }
    id_size = 10;

    if (!cmp_read_pfix(cmp, &id)) {
      error_and_exit(cmp_strerror(cmp));
    }
    //printf("typedef %s = %u;\n", key, id);
  }
}

void read_types (cmp_ctx_t *cmp) {
  uint32_t map_size;
  if (!cmp_read_map(cmp, &map_size)) {
    error_and_exit(cmp_strerror(cmp));
  }

  uint32_t key_size = 12;
  char key[key_size];
  uint32_t sub_key_size = 20;
  char sub_key[sub_key_size]; 
  uint32_t prefix_size = 14;
  char prefix[prefix_size];

  uint8_t id;
  for (int i = 0; i < map_size; i++) {
    if(!cmp_read_str(cmp, key, &key_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }
    key_size = 12;

    uint32_t sub_map_size;
    if (!cmp_read_map(cmp, &sub_map_size)) {
      error_and_exit(cmp_strerror(cmp));
    }

    for (int j = 0; j < sub_map_size; j++) {
      if(!cmp_read_str(cmp, sub_key, &sub_key_size)) { // TODO: wrap this
        error_and_exit(cmp_strerror(cmp));
      }
      sub_key_size = 20;

      if (strcmp(sub_key, "id") == 0) {
        if (!cmp_read_pfix(cmp, &id)) {
          error_and_exit(cmp_strerror(cmp));
        }
      } else {
        if(!cmp_read_str(cmp, prefix, &prefix_size)) { // TODO: wrap this
          error_and_exit(cmp_strerror(cmp));
        }
        prefix_size = 14;
      }
    }

    printf("typedef uint8_t %s;\n", key);
    printf("#define NVIM_EXT_%s %i\n", key, id);
  }
  printf("\n");
}

void read_map (cmp_ctx_t *cmp, cmp_object_t cmp_obj) {
  uint32_t map_size = cmp_obj.as.map_size;
  uint32_t key_size = 12;
  uint32_t num_fns;
  func_t *fns;
  char key[key_size];
  for (int i = 0; i < map_size; i++) {
    if(!cmp_read_str(cmp, key, &key_size)) { // TODO: wrap this
      error_and_exit(cmp_strerror(cmp));
    }
    key_size = 12;

    if (strcmp(key, "version") == 0) {
      read_version(cmp);
    } else if (strcmp(key, "functions") == 0) {
      read_functions(cmp, &fns, &num_fns);
    } else if (strcmp(key, "error_types") == 0) {
      read_error_types(cmp);
    } else if (strcmp(key, "types") == 0) {
      read_types(cmp);
    } else {
      fprintf(stderr, "unknown root key: %s\n", key);
      exit(1);
    }
  }

  for (int i = 0; i < num_fns; i++) {
    if (!fns[i].deprecated) {
      print_function(&fns[i]);
    }
    free(fns[i].params);
  }
  free(fns);
}

int main (void) {
  FILE *fp = popen("nvim --api-info", "r");
  if (fp == NULL) {
    fprintf(stderr, "failed to run nvim command\n");
    exit(1);
  }

  printf("#include <stdbool.h>\n");
  printf("#include <stdint.h>\n");
  printf("#include <stdlib.h>\n");
  printf("#include <string.h>\n");
  printf("#include \"cmp.h\"\n");
  printf("#include \"rpc.h\"\n");
  printf("\n");

  cmp_ctx_t cmp;
  cmp_init(&cmp, fp, file_reader, null_writer);

  cmp_object_t cmp_obj;
  cmp_read_object(&cmp, &cmp_obj);
  if (cmp_obj.type == CMP_TYPE_FIXMAP) {
    read_map(&cmp, cmp_obj);
  } else {
    fprintf(stderr, "unknown type: %i\n", cmp_obj.type);
    exit(1);
  }

  pclose(fp);
  return 0;
}
